{"ast":null,"code":"'use strict';\n\nconst ndjson = require('iterable-ndjson');\n\nconst bs58 = require('bs58');\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe');\n\nconst configure = require('../lib/configure');\n\nconst toIterable = require('stream-to-it/source');\n\nconst SubscriptionTracker = require('./subscription-tracker');\n\nmodule.exports = configure(config => {\n  const ky = config.ky;\n  const subsTracker = SubscriptionTracker.singleton();\n\n  const publish = require('./publish')(config);\n\n  return async (topic, handler, options) => {\n    options = options || {};\n    options.signal = subsTracker.subscribe(topic, handler, options.signal);\n    const searchParams = new URLSearchParams(options.searchParams);\n    searchParams.set('arg', topic);\n    if (options.discover != null) searchParams.set('discover', options.discover);\n    let res; // In Firefox, the initial call to fetch does not resolve until some data\n    // is received. If this doesn't happen within 1 second send an empty message\n    // to kickstart the process.\n\n    const ffWorkaround = setTimeout(async () => {\n      log(\"Publishing empty message to \\\"\".concat(topic, \"\\\" to resolve subscription request\"));\n\n      try {\n        await publish(topic, Buffer.alloc(0), options);\n      } catch (err) {\n        log('Failed to publish empty message', err);\n      }\n    }, 1000);\n\n    try {\n      res = await ky.post('pubsub/sub', {\n        timeout: options.timeout,\n        signal: options.signal,\n        headers: options.headers,\n        searchParams\n      });\n    } catch (err) {\n      // Initial subscribe fail, ensure we clean up\n      subsTracker.unsubscribe(topic, handler);\n      throw err;\n    }\n\n    clearTimeout(ffWorkaround);\n    readMessages(ndjson(toIterable(res.body)), {\n      onMessage: handler,\n      onEnd: () => subsTracker.unsubscribe(topic, handler),\n      onError: options.onError\n    });\n  };\n});\n\nasync function readMessages(msgStream, {\n  onMessage,\n  onEnd,\n  onError\n}) {\n  onError = onError || log;\n\n  try {\n    for await (const msg of msgStream) {\n      try {\n        onMessage({\n          from: bs58.encode(Buffer.from(msg.from, 'base64')).toString(),\n          data: Buffer.from(msg.data, 'base64'),\n          seqno: Buffer.from(msg.seqno, 'base64'),\n          topicIDs: msg.topicIDs\n        });\n      } catch (err) {\n        err.message = \"Failed to parse pubsub message: \".concat(err.message);\n        onError(err, false, msg); // Not fatal\n      }\n    }\n  } catch (err) {\n    // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n    // Temporarily use the name property instead.\n    if (err.type !== 'aborted' && err.name !== 'AbortError') {\n      onError(err, true); // Fatal\n    }\n  } finally {\n    onEnd();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}