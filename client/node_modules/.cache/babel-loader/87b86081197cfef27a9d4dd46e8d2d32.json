{"ast":null,"code":"'use strict';\n\nconst _require = require('ky-universal'),\n      HTTPError = _require.HTTPError;\n\nconst log = require('debug')('ipfs-http-client:lib:error-handler');\n\nconst _require2 = require('ipfs-utils/src/env'),\n      isNode = _require2.isNode,\n      isElectronMain = _require2.isElectronMain;\n\nfunction isJsonResponse(res) {\n  return (res.headers.get('Content-Type') || '').startsWith('application/json');\n}\n\nmodule.exports = async function errorHandler(input, options, response) {\n  if (response.ok) {\n    // FIXME: remove when fixed https://github.com/sindresorhus/ky-universal/issues/8\n    //\n    // ky clones the response for each handler. In Node.js the response body is\n    // piped to 2 PassThroughs, one becomes the real body and the other is used\n    // in the clone.\n    //\n    // If the body in the clone is not consumed or destroyed the highwater mark\n    // will be reached (for large payloads) and stop the real body from flowing.\n    if (isNode || isElectronMain) response.body.destroy();\n    return;\n  }\n\n  let msg;\n\n  try {\n    if (isJsonResponse(response)) {\n      const data = await response.json();\n      log(data);\n      msg = data.Message || data.message;\n    } else {\n      msg = await response.text();\n    }\n  } catch (err) {\n    log('Failed to parse error response', err); // Failed to extract/parse error message from response\n\n    msg = err.message;\n  }\n\n  const error = new HTTPError(response); // If we managed to extract a message from the response, use it\n\n  if (msg) {\n    error.message = msg;\n  }\n\n  throw error;\n};","map":null,"metadata":{},"sourceType":"script"}