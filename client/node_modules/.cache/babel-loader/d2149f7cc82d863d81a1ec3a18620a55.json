{"ast":null,"code":"import _slicedToArray from \"D:\\\\LXW\\\\truffle_proj\\\\qodpro\\\\dataTruffleSys\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/*! MIT License Â© Sindre Sorhus */\nconst globals = {};\n{\n  const getGlobal = property => {\n    let parent;\n    /* istanbul ignore next */\n\n    if (typeof self !== 'undefined' && self && property in self) {\n      parent = self;\n    }\n    /* istanbul ignore next */\n\n\n    if (typeof window !== 'undefined' && window && property in window) {\n      parent = window;\n    }\n\n    if (typeof global !== 'undefined' && global && property in global) {\n      parent = global;\n    }\n    /* istanbul ignore next */\n\n\n    if (typeof globalThis !== 'undefined' && globalThis) {\n      parent = globalThis;\n    }\n\n    if (typeof parent === 'undefined') {\n      return;\n    }\n\n    const globalProperty = parent[property];\n\n    if (typeof globalProperty === 'function') {\n      return globalProperty.bind(parent);\n    }\n\n    return globalProperty;\n  };\n\n  const globalProperties = ['document', 'Headers', 'Request', 'Response', 'ReadableStream', 'fetch', 'AbortController', 'FormData'];\n  const props = {};\n\n  for (const property of globalProperties) {\n    props[property] = {\n      get() {\n        return getGlobal(property);\n      }\n\n    };\n  }\n\n  Object.defineProperties(globals, props);\n}\n\nconst isObject = value => value !== null && typeof value === 'object';\n\nconst supportsAbortController = typeof globals.AbortController === 'function';\nconst supportsStreams = typeof globals.ReadableStream === 'function';\nconst supportsFormData = typeof globals.FormData === 'function';\n\nconst deepMerge = (...sources) => {\n  let returnValue = {};\n\n  for (const source of sources) {\n    if (Array.isArray(source)) {\n      if (!Array.isArray(returnValue)) {\n        returnValue = [];\n      }\n\n      returnValue = [...returnValue, ...source];\n    } else if (isObject(source)) {\n      for (let _ref of Object.entries(source)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        let key = _ref2[0];\n        let value = _ref2[1];\n\n        if (isObject(value) && Reflect.has(returnValue, key)) {\n          value = deepMerge(returnValue[key], value);\n        }\n\n        returnValue = { ...returnValue,\n          [key]: value\n        };\n      }\n    }\n  }\n\n  return returnValue;\n};\n\nconst requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];\nconst responseTypes = {\n  json: 'application/json',\n  text: 'text/*',\n  formData: 'multipart/form-data',\n  arrayBuffer: '*/*',\n  blob: '*/*'\n};\nconst retryMethods = new Set(['get', 'put', 'head', 'delete', 'options', 'trace']);\nconst retryStatusCodes = new Set([408, 413, 429, 500, 502, 503, 504]);\nconst retryAfterStatusCodes = new Set([413, 429, 503]);\n\nclass HTTPError extends Error {\n  constructor(response) {\n    super(response.statusText);\n    this.name = 'HTTPError';\n    this.response = response;\n  }\n\n}\n\nclass TimeoutError extends Error {\n  constructor() {\n    super('Request timed out');\n    this.name = 'TimeoutError';\n  }\n\n}\n\nconst safeTimeout = (resolve, reject, ms) => {\n  if (ms > 2147483647) {\n    // The maximum value of a 32bit int (see #117)\n    reject(new RangeError('The `timeout` option cannot be greater than 2147483647'));\n  }\n\n  return setTimeout(resolve, ms);\n};\n\nconst delay = ms => new Promise((resolve, reject) => safeTimeout(resolve, reject, ms)); // `Promise.race()` workaround (#91)\n\n\nconst timeout = (promise, ms, abortController) => new Promise((resolve, reject) => {\n  const timeoutID = safeTimeout(() => {\n    if (supportsAbortController) {\n      abortController.abort();\n    }\n\n    reject(new TimeoutError());\n  }, reject, ms);\n  /* eslint-disable promise/prefer-await-to-then */\n\n  promise.then(resolve).catch(reject).then(() => {\n    clearTimeout(timeoutID);\n  });\n  /* eslint-enable promise/prefer-await-to-then */\n});\n\nconst normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;\n\nconst defaultRetryOptions = {\n  limit: 2,\n  methods: retryMethods,\n  statusCodes: retryStatusCodes,\n  afterStatusCodes: retryAfterStatusCodes\n};\n\nconst normalizeRetryOptions = retry => {\n  if (typeof retry === 'number') {\n    return { ...defaultRetryOptions,\n      limit: retry\n    };\n  }\n\n  if (retry.methods && !Array.isArray(retry.methods)) {\n    throw new Error('retry.methods must be an array');\n  }\n\n  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {\n    throw new Error('retry.statusCodes must be an array');\n  }\n\n  return { ...defaultRetryOptions,\n    ...retry,\n    methods: retry.methods ? new Set(retry.methods) : defaultRetryOptions.methods,\n    statusCodes: retry.statusCodes ? new Set(retry.statusCodes) : defaultRetryOptions.statusCodes,\n    afterStatusCodes: retryAfterStatusCodes\n  };\n};\n\nclass Ky {\n  constructor(input, {\n    timeout = 10000,\n    hooks,\n    throwHttpErrors = true,\n    searchParams,\n    json,\n    retry = {},\n    ...otherOptions\n  }) {\n    this._retryCount = 0;\n    this._options = {\n      method: 'get',\n      credentials: 'same-origin',\n      // TODO: This can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208\n      retry: normalizeRetryOptions(retry),\n      ...otherOptions\n    };\n\n    if (input instanceof globals.Request) {\n      this._input = input; // `ky` options have precedence over `Request` options\n\n      this._options = { ...this._options,\n        method: otherOptions.method || input.method,\n        headers: otherOptions.headers || input.headers,\n        body: otherOptions.body || input.body,\n        credentials: otherOptions.credentials || input.credentials\n      };\n    } else if (!(input instanceof URL) && typeof input !== 'string') {\n      throw new TypeError('`input` must be a string, URL, or Request');\n    } else {\n      this._input = String(input || '');\n      this._options.prefixUrl = String(this._options.prefixUrl || '');\n\n      if (this._options.prefixUrl && this._input.startsWith('/')) {\n        throw new Error('`input` must not begin with a slash when using `prefixUrl`');\n      }\n\n      if (this._options.prefixUrl && !this._options.prefixUrl.endsWith('/')) {\n        this._options.prefixUrl += '/';\n      }\n\n      this._input = this._options.prefixUrl + this._input;\n\n      if (searchParams) {\n        const url = new URL(this._input, globals.document && globals.document.baseURI);\n\n        if (typeof searchParams === 'string' || URLSearchParams && searchParams instanceof URLSearchParams) {\n          url.search = searchParams;\n        } else if (Object.values(searchParams).every(param => typeof param === 'number' || typeof param === 'string')) {\n          url.search = new URLSearchParams(searchParams).toString();\n        } else {\n          throw new Error('The `searchParams` option must be either a string, `URLSearchParams` instance or an object with string and number values');\n        }\n\n        this._input = url.toString();\n      }\n    }\n\n    if (supportsAbortController) {\n      this.abortController = new globals.AbortController();\n\n      if (this._options.signal) {\n        this._options.signal.addEventListener('abort', () => {\n          this.abortController.abort();\n        });\n      }\n\n      this._options.signal = this.abortController.signal;\n    }\n\n    this._options.method = normalizeRequestMethod(this._options.method);\n    this._timeout = timeout;\n    this._hooks = deepMerge({\n      beforeRequest: [],\n      beforeRetry: [],\n      afterResponse: []\n    }, hooks);\n    this._throwHttpErrors = throwHttpErrors;\n    const headers = new globals.Headers(this._options.headers || {});\n\n    if ((supportsFormData && this._options.body instanceof globals.FormData || this._options.body instanceof URLSearchParams) && headers.has('content-type')) {\n      throw new Error(\"The `content-type` header cannot be used with a \".concat(this._options.body.constructor.name, \" body. It will be set automatically.\"));\n    }\n\n    if (json) {\n      if (this._options.body) {\n        throw new Error('The `json` option cannot be used with the `body` option');\n      }\n\n      headers.set('content-type', 'application/json');\n      this._options.body = JSON.stringify(json);\n    }\n\n    this._options.headers = headers;\n\n    const fn = async () => {\n      await delay(1);\n      let response = await this._fetch();\n\n      for (const hook of this._hooks.afterResponse) {\n        // eslint-disable-next-line no-await-in-loop\n        const modifiedResponse = await hook(this._input, this._options, response.clone());\n\n        if (modifiedResponse instanceof globals.Response) {\n          response = modifiedResponse;\n        }\n      }\n\n      if (!response.ok && this._throwHttpErrors) {\n        throw new HTTPError(response);\n      } // If `onDownloadProgress` is passed, it uses the stream API internally\n\n      /* istanbul ignore next */\n\n\n      if (this._options.onDownloadProgress) {\n        if (typeof this._options.onDownloadProgress !== 'function') {\n          throw new TypeError('The `onDownloadProgress` option must be a function');\n        }\n\n        if (!supportsStreams) {\n          throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');\n        }\n\n        return this._stream(response.clone(), this._options.onDownloadProgress);\n      }\n\n      return response;\n    };\n\n    const isRetriableMethod = this._options.retry.methods.has(this._options.method.toLowerCase());\n\n    const result = isRetriableMethod ? this._retry(fn) : fn();\n\n    for (const _ref3 of Object.entries(responseTypes)) {\n      var _ref4 = _slicedToArray(_ref3, 2);\n\n      const type = _ref4[0];\n      const mimeType = _ref4[1];\n\n      result[type] = async () => {\n        headers.set('accept', mimeType);\n        return (await result).clone()[type]();\n      };\n    }\n\n    return result;\n  }\n\n  _calculateRetryDelay(error) {\n    this._retryCount++;\n\n    if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {\n      if (error instanceof HTTPError) {\n        if (!this._options.retry.statusCodes.has(error.response.status)) {\n          return 0;\n        }\n\n        const retryAfter = error.response.headers.get('Retry-After');\n\n        if (retryAfter && this._options.retry.afterStatusCodes.has(error.response.status)) {\n          let after = Number(retryAfter);\n\n          if (Number.isNaN(after)) {\n            after = Date.parse(retryAfter) - Date.now();\n          } else {\n            after *= 1000;\n          }\n\n          if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {\n            return 0;\n          }\n\n          return after;\n        }\n\n        if (error.response.status === 413) {\n          return 0;\n        }\n      }\n\n      const BACKOFF_FACTOR = 0.3;\n      return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1000;\n    }\n\n    return 0;\n  }\n\n  async _retry(fn) {\n    try {\n      return await fn();\n    } catch (error) {\n      const ms = this._calculateRetryDelay(error);\n\n      if (ms !== 0 && this._retryCount > 0) {\n        await delay(ms);\n\n        for (const hook of this._hooks.beforeRetry) {\n          // eslint-disable-next-line no-await-in-loop\n          await hook(this._input, this._options, error, this._retryCount);\n        }\n\n        return this._retry(fn);\n      }\n\n      if (this._throwHttpErrors) {\n        throw error;\n      }\n    }\n  }\n\n  async _fetch() {\n    for (const hook of this._hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(this._input, this._options);\n\n      if (result instanceof Response) {\n        return result;\n      }\n    }\n\n    if (this._timeout === false) {\n      return globals.fetch(this._input, this._options);\n    }\n\n    return timeout(globals.fetch(this._input, this._options), this._timeout, this.abortController);\n  }\n  /* istanbul ignore next */\n\n\n  _stream(response, onDownloadProgress) {\n    const totalBytes = Number(response.headers.get('content-length')) || 0;\n    let transferredBytes = 0;\n    return new globals.Response(new globals.ReadableStream({\n      start(controller) {\n        const reader = response.body.getReader();\n\n        if (onDownloadProgress) {\n          onDownloadProgress({\n            percent: 0,\n            transferredBytes: 0,\n            totalBytes\n          }, new Uint8Array());\n        }\n\n        async function read() {\n          const _ref5 = await reader.read(),\n                done = _ref5.done,\n                value = _ref5.value;\n\n          if (done) {\n            controller.close();\n            return;\n          }\n\n          if (onDownloadProgress) {\n            transferredBytes += value.byteLength;\n            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;\n            onDownloadProgress({\n              percent,\n              transferredBytes,\n              totalBytes\n            }, value);\n          }\n\n          controller.enqueue(value);\n          read();\n        }\n\n        read();\n      }\n\n    }));\n  }\n\n}\n\nconst validateAndMerge = (...sources) => {\n  for (const source of sources) {\n    if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {\n      throw new TypeError('The `options` argument must be an object');\n    }\n  }\n\n  return deepMerge({}, ...sources);\n};\n\nconst createInstance = defaults => {\n  const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));\n\n  for (const method of requestMethods) {\n    ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {\n      method\n    }));\n  }\n\n  ky.create = newDefaults => createInstance(validateAndMerge(newDefaults));\n\n  ky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));\n\n  return ky;\n};\n\nexport default createInstance();\nexport { HTTPError, TimeoutError };","map":null,"metadata":{},"sourceType":"module"}