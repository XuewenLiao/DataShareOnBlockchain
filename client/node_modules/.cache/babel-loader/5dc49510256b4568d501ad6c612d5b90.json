{"ast":null,"code":"const _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst BufferList = require('bl/BufferList');\n\nconst _require2 = require('fs-constants'),\n      S_IFMT = _require2.S_IFMT,\n      S_IFBLK = _require2.S_IFBLK,\n      S_IFCHR = _require2.S_IFCHR,\n      S_IFDIR = _require2.S_IFDIR,\n      S_IFIFO = _require2.S_IFIFO,\n      S_IFLNK = _require2.S_IFLNK;\n\nconst concat = require('it-concat');\n\nconst Headers = require('./pack-headers');\n\nconst DMODE = parseInt('755', 8);\nconst FMODE = parseInt('644', 8);\nconst END_OF_TAR = Buffer.alloc(1024);\n\nfunction modeToType(mode) {\n  switch (mode & S_IFMT) {\n    case S_IFBLK:\n      return 'block-device';\n\n    case S_IFCHR:\n      return 'character-device';\n\n    case S_IFDIR:\n      return 'directory';\n\n    case S_IFIFO:\n      return 'fifo';\n\n    case S_IFLNK:\n      return 'symlink';\n  }\n\n  return 'file';\n}\n\nfunction getPadding(size) {\n  size &= 511;\n  if (size) return new BufferList(END_OF_TAR.slice(0, 512 - size));\n}\n\nfunction encode(header) {\n  if (!header.pax) {\n    const encoded = Headers.encode(header);\n    if (encoded) return encoded;\n  }\n\n  return encodePax(header);\n}\n\nfunction encodePax(header) {\n  const paxHeader = Headers.encodePax({\n    name: header.name,\n    linkname: header.linkname,\n    pax: header.pax\n  });\n  const newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  };\n  return new BufferList([Headers.encode(newHeader), paxHeader, getPadding(paxHeader.length), Headers.encode({ ...newHeader,\n    size: header.size,\n    type: header.type\n  })]);\n}\n\nmodule.exports = () => async function* (source) {\n  for await (let _ref of source) {\n    let header = _ref.header;\n    let body = _ref.body;\n    if (!header.size || header.type === 'symlink') header.size = 0;\n    if (!header.type) header.type = modeToType(header.mode);\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;\n    if (!header.uid) header.uid = 0;\n    if (!header.gid) header.gid = 0;\n    if (!header.mtime) header.mtime = new Date();\n    if (typeof body === 'string') body = Buffer.from(body);\n\n    if (Buffer.isBuffer(body) || BufferList.isBufferList(body)) {\n      header.size = body.length;\n      yield new BufferList([encode(header), body, getPadding(header.size)]);\n      continue;\n    }\n\n    if (header.type === 'symlink' && !header.linkname) {\n      header.linkname = (await concat(body)).toString();\n      yield encode(header);\n      continue;\n    }\n\n    yield encode(header);\n\n    if (header.type !== 'file' && header.type !== 'contiguous-file') {\n      continue;\n    }\n\n    let written = 0;\n\n    for await (const chunk of body) {\n      written += chunk.length;\n      yield BufferList.isBufferList(chunk) ? chunk : new BufferList(chunk);\n    }\n\n    if (written !== header.size) {\n      // corrupting tar\n      throw new Error('size mismatch');\n    }\n\n    const overflow = getPadding(header.size);\n    if (overflow) yield overflow;\n  }\n\n  yield new BufferList(END_OF_TAR);\n};","map":null,"metadata":{},"sourceType":"script"}